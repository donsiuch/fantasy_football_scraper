#!/usr/bin/env python3

import csv
from email.message import EmailMessage
import json
import mimetypes
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
import smtplib
from webdriver_manager.chrome import ChromeDriverManager

class Mail():
    
    SENDER_EMAIL = ""

    PASSWORD = ""

    DISCLAIMER = "\n\nThis email was autogenerated by the Fantasy Football Scraper."

    def __init__(self):

        with open('sender_email.txt', 'r') as f:
            self.SENDER_EMAIL = f.read().strip()    
        
        with open('password.txt', 'r') as f:
            self.PASSWORD = f.read().strip()    

    def send_mail(self, receiver_email, subject, body, attachments_list):

        message = EmailMessage()
        message.set_content(body + self.DISCLAIMER)
        message['Subject'] = subject
        message['From'] = self.SENDER_EMAIL
        message['To'] = receiver_email

        for file in attachments_list:
            
            path = Path(file)
            if not path.exists():
                raise FileNotFoundError(f"Attachment does not exist: {file_path}")

            # Guess MIME type and encoding
            mime_type, _ = mimetypes.guess_type(path)
            maintype, subtype = mime_type.split('/') if mime_type else ('application', 'octet-stream')

            with open(path, "rb") as f:
                file_data = f.read()

            message.add_attachment(file_data, maintype=maintype, subtype=subtype, filename=path.name)

        try:
            # Establish a connection to Gmail's SMTP server
            with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
                server.login(self.SENDER_EMAIL, self.PASSWORD)
                server.send_message(message)
                print("Email sent successfully to [{}]".format(receiver_email))
        except Exception as e:
            print(f"Error sending email: {e}")

def WebsiteFactory(website):
    
    if website == "yahoo":
        return YahooNFL()

    return None

def PlayerFactory(positionId):

    if positionId == "Receiving":
        return Receiver()

    if positionId == "Rushing":
        return RunningBack()

    if positionId == "Passing":
        return Quarterback()

    if positionId == "Kicking":
        return Kicker()

    if positionId == "Defense":
        return Defense()

    return None

def StatsFactory(positionId):
    
    if positionId == "Receiving":
        return ReceivingStats()
    
    if positionId == "Rushing":
        return RushingStats()

    if positionId == "Passing":
        return PassingStats()

    if positionId == "Kicking":
        return KickingStats()

    if positionId == "Defense":
        return Defense()

    return None

class Player():

    positionId = "?"
    url = "?"

    def to_string(self):
        print(f"""
            {self.stats_dictionary}
        """)

    def get_stats_dictionary(self):
        return self.stats_dictionary

    def extract_data_from_json_dicts(self, data):

        self.stats_dictionary['PLAYER'] = data["player"]["displayName"]
        self.stats_dictionary['TEAM'] = data["player"]["team"]["displayName"]

        # Some players are missing the following data. But since this isn't
        # required for the table, just absorb it.
        try:
            self.positionId = data["player"]["positions"][0]["positionId"]
        except Exception as e:
            pass

        try:
            self.url = data["player"]["alias"]["url"]
        except Exception as e:
            pass

        for stat in data['stats']:
            statId = stat["statId"]
            self.stats_dictionary[statId] = stat["value"] if stat["value"] is not None else 0

        # debugging
        #self.to_string()

class PassingStats():

    json_keyword = "PASSING_YARDS"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "QB_RATING" : "",
        "PASSING_COMPLETIONS" : "",
        "PASSING_ATTEMPTS" : -1,
        "COMPLETION_PERCENTAGE" : -1,
        "PASSING_YARDS" : -1,
        "PASSING_YARDS_PER_ATTEMPT" : -1,
        "PASSING_TOUCHDOWNS" : -1,
        "PASSING_INTERCEPTIONS" : -1,
        "PASSING_FIRST_DOWNS" : -1,
        "SACKS_TAKEN" : -1,
        "SACKS_YARDS_LOST" : -1,
        "FUMBLES" : -1,
        "FUMBLES_LOST" : -1
    }

class RushingStats():

    json_keyword = "RUSHING_YARDS"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "RUSHING_ATTEMPTS" : -1,
        "RUSHING_YARDS" : -1,
        "RUSHING_YARDS_PER_ATTEMPT" : -1,
        "RUSHING_TOUCHDOWNS" : -1,
        "RUSHING_FIRST_DOWNS" : -1,
        "LONGEST_RUSH" : -1,
        "FUMBLES" : -1,
        "FUMBLES_LOST" : -1
    }

class ReceivingStats():

    json_keyword = "RECEIVING_YARDS"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "RECEPTIONS" : -1,
        "TARGETS" : -1,
        "RECEIVING_YARDS" : -1,
        "RECEIVING_YARDS_PER_RECEPTION" : -1,
        "LONGEST_RECEPTION" : -1,
        "RECEIVING_FIRST_DOWNS" : -1,
        "RECEIVING_TOUCHDOWNS" : -1,
        "FUMBLES" : -1,
        "FUMBLES_LOST" : -1
    }

class KickingStats():

    json_keyword = "FIELD_GOALS_MADE"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "FIELD_GOALS_MADE_0_19" : -1,
        "FIELD_GOAL_ATTEMPTS_0_19" : -1,
        "FIELD_GOALS_MADE_20_29" : -1, 
        "FIELD_GOAL_ATTEMPTS_20_29" : -1,
        "FIELD_GOALS_MADE_30_39": -1,
        "FIELD_GOAL_ATTEMPTS_30_39" : -1,
        "FIELD_GOALS_MADE_40_49" : -1,
        "FIELD_GOAL_ATTEMPTS_40_49" : -1,
        "FIELD_GOALS_MADE_50_PLUS" : -1,
        "FIELD_GOAL_ATTEMPTS_50_PLUS" : -1,
        "FIELD_GOALS_MADE" : -1,
        "FIELD_GOAL_ATTEMPTS" : -1,
        "FIELD_GOAL_PERCENTAGE" : -1,
        "LONGEST_FIELD_GOAL" : -1,
        "EXTRA_POINTS_MADE" : -1,
        "EXTRA_POINT_ATTEMPTS" : -1,
        "EXTRA_POINT_PERCENTAGE" : -1
    }

class DefenseStats():

    json_keyword = "TOTAL_TACKLES"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "SOLO_TACKLES" : -1,
        "TACKLE_ASSISTS" : -1,
        "TOTAL_TACKLES" : -1,
        "SACKS" : -1,
        "SACKS_YARDS" : -1,
        "STUFFS" : -1,
        "INTERCEPTIONS_FORCED" : -1,
        "INTERCEPTION_RETURN_YARDS" : -1,
        "INTERCEPTION_RETURN_TOUCHDOWNS" : -1,
        "FORCED_FUMBLES" : -1,
        "FUMBLE_RETURN_TOUCHDOWNS" : -1,
        "PASSES_DEFENDED" : -1,
        "SAFETIES" : -1
    }

class Quarterback(Player, PassingStats):
    def __init__(self):
        pass

class Receiver(Player, ReceivingStats):
    def __init__(self):
        pass

class RunningBack(Player, RushingStats):
    def __init__(self):
        pass

class Kicker(Player, KickingStats):
    def __init__(self):
        pass

class Defense(Player, DefenseStats):
    def __init__(self):
        pass

class YahooNFL():

    csv_file_list = []

    def find_key_recursive(self, d, key):
        if isinstance(d, dict):
            if key in d:
                return d[key]
            for k, v in d.items():
                result = self.find_key_recursive(v, key)
                if result is not None:
                    return result
        elif isinstance(d, list):
            for item in d:
                result = self.find_key_recursive(item, key)
                if result is not None:
                    return result
        return None

    def dump_data_to_file(self, data, filename):
        #
        # Debugging: This dumps the data
        #
        if data:
            with open(filename, "w") as f:
                json.dump(data, f, indent=2)
            print(f"App data saved to {filename}")
        else:
            print("App.main not found.")

    def email_csvs(self):

        email = Mail()
        
        with open('email_list.json') as f:

            email_list = json.load(f)
            
            for email_address in email_list['recipients']:
                email.send_mail(email_address, 
                    "Fantasy Football Scrape Results",
                    "CSVs are attached.",
                    self.csv_file_list)

    def scrape_stats(self):

        # Optional: run headless (no GUI)
        options = Options()
        
        # Wait for DOMContentLoaded (don't wait for the whole page to load)
        # without this the page loads, but never finishes and the driver.get(url) times out
        options.page_load_strategy = 'eager'

        options.add_argument('--headless=new')  # Uncomment for headless mode
        options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/115.0 Safari/537.36")

        """
        # Use a common browser user agent string
        user_agent = (
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
            "(KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36"
        )

        options.add_argument(f"user-agent={user_agent}")
        """
        # Optional: speed it up
        # TODO: Is this really necessary?
        #options.add_argument("--disable-blink-features=AutomationControlled")
        #options.add_argument("--no-sandbox")
        #options.add_argument("--disable-dev-shm-usage")

        service = Service(ChromeDriverManager().install()) 
        driver = webdriver.Chrome(service=service, options=options)

        try:
            # Load the Yahoo Sports NFL stats page (or other target)
            url = "https://sports.yahoo.com/nfl/stats/weekly"
            print(f"driver.get({url})")
            driver.get(url)

            # Wait for JS to load and populate root.App
            #time.sleep(5)  # Adjust as needed, or use WebDriverWait for reliability
            WebDriverWait(driver, timeout=15).until(
                lambda d: d.execute_script("return typeof window.App?.main !== 'undefined';")
            )

            # Use JavaScript to access the embedded object
            app_data = driver.execute_script("return window.App?.main;")

            self.dump_data_to_file(app_data, "MASTER.json")

            keyword = ["Passing", "Rushing", "Receiving", "Kicking", "Defense"]

            for key in keyword:

                receiving_data = self.find_key_recursive(app_data, "weeklyStatsFootball" + key)

                #self.dump_data_to_file(receiving_data, key + ".json")

                stats_data = StatsFactory(key)
                
                receiving = (receiving_data
                    .get("nfl", {})
                    .get("200", {})
                    .get("2025", {})
                    .get("2", {})
                    .get("PRESEASON", {})
                    .get("", {})
                    .get(stats_data.json_keyword, {})
                )

                leaders = receiving["leagues"][0]["leagueWeeks"][0]["leaders"]

                csv_filename = "{}_stats.csv".format(key)
                with open(csv_filename, mode='w', newline='') as file:

                    dictionary = stats_data.stats_dictionary

                    # Write header
                    writer = csv.DictWriter(file, fieldnames = list(dictionary.keys()))
                    writer.writeheader()

                    for leader in leaders:
                        player = PlayerFactory(key)

                        player.extract_data_from_json_dicts(leader)

                        #print(player.get_stats_dictionary()) # DEBUG
                        writer.writerows([player.get_stats_dictionary()])

                print(f"Created {csv_filename}")

                self.csv_file_list.append(csv_filename)

        finally:
            driver.quit()

class Program():

    def work_loop(self):

        website = WebsiteFactory("yahoo")

        website.scrape_stats()

        website.email_csvs()

    def main(self):
        
        self.work_loop()
        

if __name__ == "__main__":

    p = Program()

    p.main()

