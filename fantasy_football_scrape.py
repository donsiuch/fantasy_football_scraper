#!/usr/bin/env python3

import csv
from email.message import EmailMessage
import json
import mimetypes
from pathlib import Path
import re
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
import smtplib
from webdriver_manager.chrome import ChromeDriverManager

def WebsiteFactory(website):
    
    if website == "yahoo":
        return YahooNFL()

    return None

def StatsFactory(positionId):
    
    if positionId == "Receiving":
        return ReceivingStats()
    
    if positionId == "Rushing":
        return RushingStats()

    if positionId == "Passing":
        return PassingStats()

    if positionId == "Kicking":
        return KickingStats()

    if positionId == "Kickoffs":
        return KickoffsStats()

    if positionId == "Punting":
        return PuntingStats()

    if positionId == "Returns":
        return ReturnsStats()

    if positionId == "Defense":
        return DefenseStats()

    return None

class Mail():
    
    SENDER_EMAIL = ""

    PASSWORD = ""

    DISCLAIMER = "\n\nThis email was autogenerated by the Fantasy Football Scraper."

    def __init__(self):

        with open('sender_email.txt', 'r') as f:
            self.SENDER_EMAIL = f.read().strip()    
        
        with open('password.txt', 'r') as f:
            self.PASSWORD = f.read().strip()    

    def send_mail(self, receiver_email, subject, body, attachments_list):

        message = EmailMessage()
        message.set_content(body + self.DISCLAIMER)
        message['Subject'] = subject
        message['From'] = self.SENDER_EMAIL
        message['To'] = receiver_email

        for file in attachments_list:
            
            path = Path(file)
            if not path.exists():
                raise FileNotFoundError(f"Attachment does not exist: {file_path}")

            # Guess MIME type and encoding
            mime_type, _ = mimetypes.guess_type(path)
            maintype, subtype = mime_type.split('/') if mime_type else ('application', 'octet-stream')

            with open(path, "rb") as f:
                file_data = f.read()

            message.add_attachment(file_data, maintype=maintype, subtype=subtype, filename=path.name)

        try:
            # Establish a connection to Gmail's SMTP server
            with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
                server.login(self.SENDER_EMAIL, self.PASSWORD)
                server.send_message(message)
                print("Email sent successfully to [{}]".format(receiver_email))
        except Exception as e:
            print(f"Error sending email: {e}")

class Player():

    positionId = "?"
    url = "?"

    stats = None

    def __init__(self, table_type):
        self.stats = StatsFactory(table_type)

    def to_string(self):
        print(f"""
            {self.stats.stats_dictionary}
        """)

    def get_stats_dictionary(self):
        return self.stats.stats_dictionary

    def extract_data_from_json_dicts(self, data):

        self.stats.stats_dictionary['PLAYER'] = data["player"]["displayName"]
        self.stats.stats_dictionary['TEAM'] = data["player"]["team"]["displayName"]

        # Some players are missing the following data. But since this isn't
        # required for the table, just absorb it.
        try:
            self.positionId = data["player"]["positions"][0]["positionId"]
        except Exception as e:
            pass

        try:
            self.url = data["player"]["alias"]["url"]
        except Exception as e:
            pass

        for stat in data['stats']:
            statId = stat["statId"]
            self.stats.stats_dictionary[statId] = stat["value"] if stat["value"] is not None else 0

        # debugging
        #self.to_string()

class PassingStats():

    stats_keyword = "PASSING_YARDS"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "QB_RATING" : "",
        "PASSING_COMPLETIONS" : "",
        "PASSING_ATTEMPTS" : -1,
        "COMPLETION_PERCENTAGE" : -1,
        "PASSING_YARDS" : -1,
        "PASSING_YARDS_PER_ATTEMPT" : -1,
        "PASSING_TOUCHDOWNS" : -1,
        "PASSING_INTERCEPTIONS" : -1,
        "PASSING_FIRST_DOWNS" : -1,
        "SACKS_TAKEN" : -1,
        "SACKS_YARDS_LOST" : -1,
        "FUMBLES" : -1,
        "FUMBLES_LOST" : -1
    }

class RushingStats():

    stats_keyword = "RUSHING_YARDS"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "RUSHING_ATTEMPTS" : -1,
        "RUSHING_YARDS" : -1,
        "RUSHING_YARDS_PER_ATTEMPT" : -1,
        "RUSHING_TOUCHDOWNS" : -1,
        "RUSHING_FIRST_DOWNS" : -1,
        "LONGEST_RUSH" : -1,
        "FUMBLES" : -1,
        "FUMBLES_LOST" : -1
    }

class ReceivingStats():

    stats_keyword = "RECEIVING_YARDS"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "RECEPTIONS" : -1,
        "TARGETS" : -1,
        "RECEIVING_YARDS" : -1,
        "RECEIVING_YARDS_PER_RECEPTION" : -1,
        "LONGEST_RECEPTION" : -1,
        "RECEIVING_FIRST_DOWNS" : -1,
        "RECEIVING_TOUCHDOWNS" : -1,
        "FUMBLES" : -1,
        "FUMBLES_LOST" : -1
    }

class KickingStats():

    stats_keyword = "FIELD_GOALS_MADE"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "FIELD_GOALS_MADE_0_19" : -1,
        "FIELD_GOAL_ATTEMPTS_0_19" : -1,
        "FIELD_GOALS_MADE_20_29" : -1, 
        "FIELD_GOAL_ATTEMPTS_20_29" : -1,
        "FIELD_GOALS_MADE_30_39": -1,
        "FIELD_GOAL_ATTEMPTS_30_39" : -1,
        "FIELD_GOALS_MADE_40_49" : -1,
        "FIELD_GOAL_ATTEMPTS_40_49" : -1,
        "FIELD_GOALS_MADE_50_PLUS" : -1,
        "FIELD_GOAL_ATTEMPTS_50_PLUS" : -1,
        "FIELD_GOALS_MADE" : -1,
        "FIELD_GOAL_ATTEMPTS" : -1,
        "FIELD_GOAL_PERCENTAGE" : -1,
        "LONGEST_FIELD_GOAL" : -1,
        "EXTRA_POINTS_MADE" : -1,
        "EXTRA_POINT_ATTEMPTS" : -1,
        "EXTRA_POINT_PERCENTAGE" : -1
    }

class KickoffsStats():

    stats_keyword = "KICKOFF_YARDS"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "KICKOFFS" : -1,
        "KICKOFF_YARDS" : -1,
        "KICKOFF_YARDS_PER_KICKOFF" : -1, 
        "LONGEST_KICKOFF" : -1,
        "KICKOFFS_FAIR_CAUGHT": -1,
        "KICKOFF_TOUCHBACKS" : -1,
        "KICKOFFS_RETURNED" : -1,
        "RETURN_YARDS_ALLOWED_PER_KICKOFF" : -1,
        "KICKOFFS_RETURNED_FOR_TOUCHDOWN" : -1,
    }

class PuntingStats():

    stats_keyword = "PUNT_YARDS"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "PUNTS" : -1,
        "PUNT_YARDS" : -1,
        "PUNT_YARDS_PER_PUNT" : -1, 
        "LONGEST_PUNT" : -1,
        "PUNTS_INSIDE_20": -1,
        "PUNTS_FAIR_CAUGHT" : -1,
        "PUNT_TOUCHBACKS" : -1,
        "PUNTS_BLOCKED" : -1,
        "PUNTS_RETURNED" : -1,
        "RETURN_YARDS_ALLOWED_PER_PUNT" : -1,
    }

class ReturnsStats():

    stats_keyword = "RETURN_YARDS_PER_KICKOFF"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "KICKOFF_RETURNS" : -1,
        "KICKOFF_RETURN_YARDS" : -1,
        "RETURN_YARDS_PER_KICKOFF" : -1, 
        "LONGEST_KICKOFF_RETURN" : -1,
        "KICKOFF_RETURN_TOUCHDOWNS": -1,
        "PUNT_RETURNS" : -1,
        "PUNT_RETURN_YARDS" : -1,
        "RETURN_YARDS_PER_PUNT" : -1,
        "LONGEST_PUNT_RETURN" : -1,
        "PUNT_RETURN_TOUCHDOWNS" : -1,
    }

class DefenseStats():

    stats_keyword = "TOTAL_TACKLES"

    stats_dictionary = { 
        "PLAYER" : "",
        "TEAM" : "",
        "SOLO_TACKLES" : -1,
        "TACKLE_ASSISTS" : -1,
        "TOTAL_TACKLES" : -1,
        "SACKS" : -1,
        "SACKS_YARDS" : -1,
        "STUFFS" : -1,
        "INTERCEPTIONS_FORCED" : -1,
        "INTERCEPTION_RETURN_YARDS" : -1,
        "INTERCEPTION_RETURN_TOUCHDOWNS" : -1,
        "FORCED_FUMBLES" : -1,
        "FUMBLE_RETURN_TOUCHDOWNS" : -1,
        "PASSES_DEFENDED" : -1,
        "SAFETIES" : -1
    }

class YahooNFL():

    csv_file_list = []

    def find_key_recursive(self, d, key):
        if isinstance(d, dict):
            if key in d:
                return d[key]
            for k, v in d.items():
                result = self.find_key_recursive(v, key)
                if result is not None:
                    return result
        elif isinstance(d, list):
            for item in d:
                result = self.find_key_recursive(item, key)
                if result is not None:
                    return result
        return None

    def dump_data_to_file(self, data, filename):
        #
        # Debugging: This dumps the data
        #
        if data:
            with open(filename, "w") as f:
                json.dump(data, f, indent=2)
            print(f"App data saved to {filename}")
        else:
            print("App.main not found.")

    def email_csvs(self):

        email = Mail()
        
        with open('email_list.json') as f:

            email_list = json.load(f)
            
            for email_address in email_list['recipients']:
                email.send_mail(email_address, 
                    "Fantasy Football Scrape Results",
                    "CSVs are attached.",
                    self.csv_file_list)

    def get_current_week(self, driver):
        html = driver.page_source

        pattern = r'<!-- -->Week (\d+)<!-- -->'

        matches = re.findall(pattern, html)

        if not matches:
            raise ValueError("No week number found in the HTML!")

        return matches[0]

    def scrape_stats(self, url):

        # Optional: run headless (no GUI)
        options = Options()
        
        # Wait for DOMContentLoaded (don't wait for the whole page to load)
        # without this the page loads, but never finishes and the driver.get(url) times out
        options.page_load_strategy = 'eager'

        options.add_argument('--headless=new')  # Uncomment for headless mode
        options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/115.0 Safari/537.36")

        service = Service(ChromeDriverManager().install()) 
        driver = webdriver.Chrome(service=service, options=options)

        try:
            # Load the Yahoo Sports NFL stats page (or other target)
            print(f"driver.get({url})")
            driver.get(url)

            week = self.get_current_week(driver)

            print(f"WEEK = {week}")

            # Use JavaScript to access the embedded object
            app_data = driver.execute_script("return window.App?.main;")

            self.dump_data_to_file(app_data, "MASTER.json")

            table_types = [
                "Passing", 
                "Rushing", 
                "Receiving", 
                "Kicking", 
                "Kickoffs", 
                "Punting", 
                "Returns", 
                "Defense"
            ]

            for table_type in table_types:

                json_table = self.find_key_recursive(app_data, "weeklyStatsFootball" + table_type)

                #self.dump_data_to_file(json_table, table_type + ".json")

                stats = StatsFactory(table_type)
                
                json_players_table = (json_table
                    .get("nfl", {})
                    .get("200", {})
                    .get("2025", {})
                    .get(week, {})
                    .get("PRESEASON", {})
                    .get("", {})
                    .get(stats.stats_keyword, {})
                )

                leaders = json_players_table["leagues"][0]["leagueWeeks"][0]["leaders"]

                csv_filename = "{}_stats.csv".format(table_type)
                with open(csv_filename, mode='w', newline='') as file:

                    stats_dictionary = stats.stats_dictionary

                    # Write header
                    writer = csv.DictWriter(file, fieldnames = list(stats_dictionary.keys()))
                    writer.writeheader()

                    for leader in leaders:

                        player = Player(table_type)

                        player.extract_data_from_json_dicts(leader)

                        #print(player.get_stats_dictionary()) # DEBUG
                        writer.writerows([player.get_stats_dictionary()])

                print(f"Created {csv_filename}")

                self.csv_file_list.append(csv_filename)

        finally:
            driver.quit()

class Program():

    def work_loop(self):

        website = WebsiteFactory("yahoo")

        website.scrape_stats("https://sports.yahoo.com/nfl/stats/weekly")

        website.email_csvs()

    def main(self):
        
        self.work_loop()
        

if __name__ == "__main__":

    p = Program()

    p.main()

